// Generated by Apple Swift version 4.1.2 (swiftlang-902.0.54 clang-902.0.39.2)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <objc/NSObject.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...)
# endif
#endif

#if __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if __has_attribute(objc_method_family)
# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
#else
# define SWIFT_METHOD_FAMILY(X)
#endif
#if __has_attribute(noescape)
# define SWIFT_NOESCAPE __attribute__((noescape))
#else
# define SWIFT_NOESCAPE
#endif
#if __has_attribute(warn_unused_result)
# define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
#else
# define SWIFT_WARN_UNUSED_RESULT
#endif
#if __has_attribute(noreturn)
# define SWIFT_NORETURN __attribute__((noreturn))
#else
# define SWIFT_NORETURN
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if defined(__has_attribute) && __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR __attribute__((enum_extensibility(open)))
# else
#  define SWIFT_ENUM_ATTR
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name) enum _name : _type _name; enum SWIFT_ENUM_ATTR SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME) SWIFT_ENUM(_type, _name)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if __has_feature(attribute_diagnose_if_objc)
# define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
#else
# define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
#endif
#if __has_feature(modules)
@import UIKit;
@import AVFoundation;
@import CoreMedia;
#endif

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="VideoLiveStreamingDemo",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif

@class UIWindow;

SWIFT_CLASS("_TtC22VideoLiveStreamingDemo11AppDelegate")
@interface AppDelegate : UIResponder <UIApplicationDelegate>
/// TODO add here
/// authors:
/// mvisoiu
/// note:
/// Based on <a href="https://github.com/MerchV/VideoLiveStreaming">VideoLiveStreaming</a> from mvisoiu
@property (nonatomic, strong) UIWindow * _Nullable window;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class UIButton;
@class UIStoryboardSegue;
@class UITextField;
@class UIPickerView;
@class NSBundle;
@class NSCoder;

/// The setting View Controller controls the storyboard. The user can change some settings
/// author:
/// Simon Reisinger
SWIFT_CLASS("_TtC22VideoLiveStreamingDemo22SettingsViewController")
@interface SettingsViewController : UIViewController <UIPickerViewDataSource, UIPickerViewDelegate, UITextFieldDelegate>
/// Called after the controller’s view is loaded into memory.
/// This method is called after the view controller has loaded its view hierarchy into memory. This method is called regardless of whether the view hierarchy was loaded from a nib file or created programmatically in the loadView() method. You usually override this method to perform additional initialization on views that were loaded from nib files.
/// author:
/// Simon Reisinger
- (void)viewDidLoad;
/// Sent to the view controller when the app receives a memory warning.
/// Your app never calls this method directly. Instead, this method is called when the system determines that the amount of available memory is low.
/// You can override this method to release any additional memory used by your view controller. If you do, your implementation of this method must call the super implementation at some point.
- (void)didReceiveMemoryWarning;
/// Disables Autorotate for this Storyboard
@property (nonatomic, readonly) BOOL shouldAutorotate;
/// Returns to main storyboard without saving the changes
/// \param sender interaction with button
///
- (IBAction)backButtonActionWithSender:(UIButton * _Null_unspecified)sender;
/// Saves the current settings and returns to the main storyboard
/// author:
/// Simon Reisinger
- (IBAction)saveButtonActionWithSender:(UIButton * _Null_unspecified)sender;
/// Notifies the view controller that a segue is about to be performed.
/// The default implementation of this method does nothing. Subclasses override this method and use it to configure the new view controller prior to it being displayed. The segue object contains information about the transition, including references to both view controllers that are involved.
/// Because segues can be triggered from multiple sources, you can use the information in the segue and sender parameters to disambiguate between different logical paths in your app. For example, if the segue originated from a table view, the sender parameter would identify the table view cell that the user tapped. You could then use that information to set the data on the destination view controller.
/// \param segue The segue object containing information about the view controllers involved in the segue.
///
/// \param sender The object that initiated the segue. You might use this parameter to perform different actions based on which control (or other object) initiated the segue.
///
- (void)prepareForSegue:(UIStoryboardSegue * _Nonnull)segue sender:(id _Nullable)sender;
/// Asks the delegate if the text field should process the pressing of the return button.
/// The text field calls this method whenever the user taps the return button. You can use this method to implement any custom behavior when the button is tapped. For example, if you want to dismiss the keyboard when the user taps the return button, your implementation can call the resignFirstResponder() method.
/// \param textField The text field whose return button was pressed.
///
///
/// returns:
/// true if the text field should implement its default behavior for the return button; otherwise, false.
- (BOOL)textFieldShouldReturn:(UITextField * _Nonnull)textField SWIFT_WARN_UNUSED_RESULT;
/// Called by the picker view when it needs the number of components.
/// \param pickerView The picker view requesting the data.
///
///
/// returns:
/// The number of components (or “columns”) that the picker view should display.
- (NSInteger)numberOfComponentsInPickerView:(UIPickerView * _Nonnull)pickerView SWIFT_WARN_UNUSED_RESULT;
/// Called by the picker view when it needs the number of rows for a specified component.
/// \param pickerView The picker view requesting the data.
///
/// \param component A zero-indexed number identifying a component of pickerView. Components are numbered left-to-right.
///
///
/// returns:
/// The number of rows for the component.
- (NSInteger)pickerView:(UIPickerView * _Nonnull)pickerView numberOfRowsInComponent:(NSInteger)component SWIFT_WARN_UNUSED_RESULT;
/// Called by the picker view when it needs the title to use for a given row in a given component.
/// If you implement both this method and the pickerView(<em>:attributedTitleForRow:forComponent:) method, the picker view prefers the pickerView(</em>:attributedTitleForRow:forComponent:) method. However, if that method returns nil, the picker view falls back to using the string returned by this method.
/// \param pickerView An object representing the picker view requesting the data.
///
/// \param row A zero-indexed number identifying a row of component. Rows are numbered top-to-bottom.
///
/// \param component A zero-indexed number identifying a component of pickerView. Components are numbered left-to-right.
///
///
/// returns:
/// The string to use as the title of the indicated component row.
- (NSString * _Nullable)pickerView:(UIPickerView * _Nonnull)pickerView titleForRow:(NSInteger)row forComponent:(NSInteger)component SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)initWithNibName:(NSString * _Nullable)nibNameOrNil bundle:(NSBundle * _Nullable)nibBundleOrNil OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
@end

@class UIView;
@class AVCaptureDataOutputSynchronizer;
@class AVCaptureSynchronizedDataCollection;
@class AVCaptureOutput;
@class AVCaptureConnection;
@class AVCaptureDepthDataOutput;
@class AVDepthData;
@class NSTimer;
@class NSNotification;

/// Controlls a storyboard. Can Stream Depth and Video Data to a Webserver
/// authors:
/// Michael Pointner, Simon Reisinger, mvisoiu
/// note:
/// Based on <a href="https://github.com/MerchV/VideoLiveStreaming">VideoLiveStreaming</a> from mvisoiu
SWIFT_CLASS("_TtC22VideoLiveStreamingDemo14ViewController")
@interface ViewController : UIViewController <AVCaptureDataOutputSynchronizerDelegate, AVCaptureDepthDataOutputDelegate, AVCaptureVideoDataOutputSampleBufferDelegate>
/// Previews the output data from the RGB camera on the screen
@property (nonatomic, strong) IBOutlet UIView * _Null_unspecified preview;
/// Called after the controller’s view is loaded into memory.
/// This method is called after the view controller has loaded its view hierarchy into memory. This method is called regardless of whether the view hierarchy was loaded from a nib file or created programmatically in the loadView() method. You usually override this method to perform additional initialization on views that were loaded from nib files.
- (void)viewDidLoad;
/// Disables Autorotate for this Storyboard
@property (nonatomic, readonly) BOOL shouldAutorotate;
/// takes photo and streams it to the server
- (IBAction)takePhotoWithSender:(UIButton * _Null_unspecified)sender;
/// Starts/Stops the streaming of the app
- (IBAction)startstopstreamingWithSender:(UIButton * _Null_unspecified)sender;
/// Opens Settings Story board if there is no streaming
- (IBAction)openSettingsButtonPressedWithSender:(UIButton * _Null_unspecified)sender;
/// Provides a collection of synchronized capture data to the delegate.
/// Use the data collection’s synchronizedData(for:) method (or equivalent subscript(_:) operator) to retrieve the captured data corresponding to each capture output.
/// \param synchronizer The synchronizer object delivering synchronized data.
///
/// \param synchronizedDataCollection A collection of data samples, one for each capture output governed by the data output synchronizer for which capture data is ready.
///
- (void)dataOutputSynchronizer:(AVCaptureDataOutputSynchronizer * _Nonnull)synchronizer didOutputSynchronizedDataCollection:(AVCaptureSynchronizedDataCollection * _Nonnull)synchronizedDataCollection;
/// Notifies the delegate that a video frame was discarded.
/// Delegates receive this message whenever a late video frame is dropped. This method is called once for each dropped frame. It is called on the dispatch queue specified by the output’s sampleBufferCallbackQueue property.
/// The sampleBuffer will contain a kCMSampleBufferAttachmentKey_DroppedFrameReason attachment that details why the frame was dropped. The frame may be dropped because it was late (kCMSampleBufferDroppedFrameReason_FrameWasLate), typically caused by the client’s processing taking too long. It can also be dropped because the module providing frames is out of buffers (kCMSampleBufferDroppedFrameReason_OutOfBuffers). Frames can also be dropped due to a discontinuity (kCMSampleBufferDroppedFrameReason_Discontinuity), if the module providing sample buffers has experienced a discontinuity, and an unknown number of frames have been lost. This condition is typically caused by the system being too busy.
/// Because this method is called on the same dispatch queue that is responsible for outputting video frames, it must be efficient to prevent further capture performance problems, such as additional dropped video frames.
/// \param captureOutput The capture output object.
///
/// \param sampleBuffer A CMSampleBuffer object containing information about the dropped frame, such as its format and presentation time.. This sample buffer contains none of the original video data.
///
/// \param connection The connection from which the video was received.
///
- (void)captureOutput:(AVCaptureOutput * _Nonnull)captureOutput didDropSampleBuffer:(CMSampleBufferRef _Nonnull)sampleBuffer fromConnection:(AVCaptureConnection * _Nonnull)connection;
/// Notifies the delegate that a new video frame was written.
/// Delegates receive this message whenever the output captures and outputs a new video frame, decoding or re-encoding it as specified by its videoSettings property. Delegates can use the provided video frame in conjunction with other APIs for further processing.
/// This method is called on the dispatch queue specified by the output’s sampleBufferCallbackQueue property. It is called periodically, so it must be efficient to prevent capture performance problems, including dropped frames.
/// If you need to reference the CMSampleBuffer object outside of the scope of this method, you must CFRetain it and then CFRelease it when you are finished with it.
/// To maintain optimal performance, some sample buffers directly reference pools of memory that may need to be reused by the device system and other capture inputs. This is frequently the case for uncompressed device native capture where memory blocks are copied as little as possible. If multiple sample buffers reference such pools of memory for too long, inputs will no longer be able to copy new samples into memory and those samples will be dropped.
/// If your application is causing samples to be dropped by retaining the provided CMSampleBuffer objects for too long, but it needs access to the sample data for a long period of time, consider copying the data into a new buffer and then releasing the sample buffer (if it was previously retained) so that the memory it references can be reused.
/// \param captureOutput The capture output object.
///
/// \param sampleBuffer A CMSampleBuffer object containing the video frame data and additional information about the frame, such as its format and presentation time.
///
/// \param connection The connection from which the video was received.
///
- (void)captureOutput:(AVCaptureOutput * _Nonnull)output didOutputSampleBuffer:(CMSampleBufferRef _Nonnull)sampleBuffer fromConnection:(AVCaptureConnection * _Nonnull)connection;
/// Informs the delegate that captured depth data was not processed.
/// The capture output calls this method once for each dropped depth data whenever data is dropped. The object in the depthData parameter is an empty shell, containing no actual depth data backing pixel buffer
/// The capture output calls this method on the dispatch queue specified by its delegateCallbackQueue property. Because this method executes on the same dispatch queue that outputs depth data, your implementation must be efficient to prevent further capture performance problems such as additional drops.
/// \param output The depth data output providing data.
///
/// \param depthData A depth data object containing information about the dropped data, such as its data type. Because this depth data was not captured or processed, its depthDataMap property is empty.
///
/// \param timestamp The time at which the data was captured.
///
/// \param connection The capture connection through which the data was captured.
///
/// \param reason The reason depth data was dropped
///
- (void)depthDataOutput:(AVCaptureDepthDataOutput * _Nonnull)output didDropDepthData:(AVDepthData * _Nonnull)didDrop timestamp:(CMTime)timestamp connection:(AVCaptureConnection * _Nonnull)connection reason:(AVCaptureOutputDataDroppedReason)reason;
/// Provides newly captured depth data to the delegate.
/// The depth data output calls this method whenever it captures and outputs a new depth data object. This method is called on the dispatch queue specified by the output’s delegateCallbackQueue property, and can be called frequently. Your implementation must process the depth data quickly in order to prevent dropped depth data.
/// To maintain optimal performance, the capture pipeline may allocate AVDepthData pixel buffer maps from a finite memory pool. If you hold onto any AVDepthData objects for too long, capture inputs cannot copy new depth data into memory, resulting in dropped depth data. If your application is causing depth data drops by holding on to provided depth data objects for too long, consider copying the pixel buffer map data into a new pixel buffer so that the AVDepthData backing memory can be reused more quickly.
/// \param output The depth data output providing data.
///
/// \param depthData A depth data object containing the captured per-pixel depth data.
///
/// \param timestamp The time at which the data was captured.
///
/// \param connection The capture connection through which the data was captured.
///
- (void)depthDataOutput:(AVCaptureDepthDataOutput * _Nonnull)depthDataOutput didOutputDepthData:(AVDepthData * _Nonnull)depthData timestamp:(CMTime)timestamp connection:(AVCaptureConnection * _Nonnull)connection;
/// Brodcasts the collected <em>RGB</em> / <em>Depth</em> Videodata to the server when triggered
/// note:
/// Based on [VideoLiveStreaming]{https://github.com/MerchV/VideoLiveStreaming}
/// \param myTimer current time
///
- (void)timerWithMyTimer:(NSTimer * _Nonnull)myTimer;
/// Notifies the view controller that a segue is about to be performed.
/// The default implementation of this method does nothing. Subclasses override this method and use it to configure the new view controller prior to it being displayed. The segue object contains information about the transition, including references to both view controllers that are involved.
/// Because segues can be triggered from multiple sources, you can use the information in the segue and sender parameters to disambiguate between different logical paths in your app. For example, if the segue originated from a table view, the sender parameter would identify the table view cell that the user tapped. You could then use that information to set the data on the destination view controller.
/// \param segue The segue object containing information about the view controllers involved in the segue.
///
/// \param sender The object that initiated the segue. You might use this parameter to perform different actions based on which control (or other object) initiated the segue.
///
- (void)prepareForSegue:(UIStoryboardSegue * _Nonnull)segue sender:(id _Nullable)sender;
/// Triggers when the iPhone changes orientation. Changes orientation of the screen and the video
- (void)rotated;
/// Triggeres when the app enters background and stops recording
/// author:
/// <a href="https://www.apple.com/">Apple</a>
/// note:
/// Based on a methode of <a href="com.example.apple-samplecode.AVCamPhotoFilterN5MBV7GWSJ">AVCamPhotoFilter</a> from <a href="https://www.apple.com/">Apple</a>
/// todo:
/// check if indexes should be reset ect.
- (void)didEnterBackgroundWithNotification:(NSNotification * _Nonnull)notification;
/// Triggeres when the thermel status changes an shows a notification
/// author:
/// <a href="https://www.apple.com/">Apple</a>
/// note:
/// Based on a methode of <a href="com.example.apple-samplecode.AVCamPhotoFilterN5MBV7GWSJ">AVCamPhotoFilter</a> from <a href="https://www.apple.com/">Apple</a>
- (void)thermalStateChangedWithNotification:(NSNotification * _Nonnull)notification;
- (nonnull instancetype)initWithNibName:(NSString * _Nullable)nibNameOrNil bundle:(NSBundle * _Nullable)nibBundleOrNil OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
@end

#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#pragma clang diagnostic pop
